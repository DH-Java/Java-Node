#  设计模式的重要性

- 软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希.伽玛等人在1990年代从建筑设计领域引入到计算机科学的

- 大厦VS简易房

- 拿实际工作经历来说，当一个项目开发完成后，如果客户提出增新功能，怎么办?(可扩展性，使用设计模式，软件具有很好的可扩展性)

- 如果项目开发完后，原来程序员离职，你接手维护该项目怎么办?(维护性【可读性、规范性】)

- 目前程序员门槛越来越高，一线IT公司，都会问你在实际项目中使用过什么设计模式，怎样使用的，解决了什么问题。

- 设计模式在软件哪里？

- - 面向对象（oo)--->功能模块【设计模式+算法和数据结构】-->框架【使用多种设计模式】-->架构【服务器集群】

# 设计模式的目的

编写软件过程中，程序员面临着来自 耦合度、内聚性以及可维护性、可扩展性、重用性、灵活性等多方面的挑战，设计模式是为了让程序（软件），具有更好的

1. 代码重用性（相同功能的代码，不用多次编写）
2. 可读性（代码规范性，便于其他程序员的阅读和理解）
3. 可扩展性（当需要增加新的功能时，非常的方便，称为可维护性）
4. 可靠性（当我们增加新的功能时，对原来的功能没有影响）
5. ‘使程序呈现高内聚，低耦合的特性

- 分析金句：

- - 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要”。

# 设计模式七大原则

- 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据）
- 设计模式常用的七大原则有：


## 单一职责原则：

>对类来说的，即一个类应该只负责一项职责，如类A负责两个不同职责：职责1，职责2。
>当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1,A2。

> 单一职责原则注意事项和细节
> 1）降低类的复杂性，一个类只负责一项职责
> 2）提高类的可读性，可维护性
> 3）降低变更引起的风险
> 4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

```java
package Singleresponsibility;
/*
*@Author:DH
*@Date:2021/12/16 23:23
*@Description:TODO
** @param null
*@return:
*/
public class SingleResponsibility1 {
    public static void main(String[] args) {
        vehicle vehicle = new vehicle();
        vehicle.run("汽车");
        vehicle.run("飞机");
        vehicle.run("轮船");
    }
}

//交通工具类
//方式一
//1、在方式1中的run方法中，违反了单一职责原则
//2、解决方案非常的简单，根据交通工具运行的方式不同，分解成不同的类即可
class vehicle {
    public void run(String vehicle){
        System.out.println(vehicle+"在公路运行");
    }
}


-----------------------------------------------------------------------------


package Singleresponsibility;

public class SingleResponsibility2 {
    public static void main(String[] args) {
        EarthVehicle earthVehicle = new EarthVehicle();
        FlyVehicle flyVehicle = new FlyVehicle();
        WhiterVehicle whiterVehicle = new WhiterVehicle();
        earthVehicle.run("汽车");
        flyVehicle.run("飞机");
        whiterVehicle.run("轮船");
    }
}
/*
* 交通类
* 方式二的分析
* 1、遵守单一职责原则
* 2、但是这样做的改动很大，即将类分解，同时修改客户端
* 3、改进：直接修改Vehicle类，改动的代码会比较小。
* */
class EarthVehicle{
    public void run(String EarthVehicle){
        System.out.println(EarthVehicle +"在公路上运行");
    }
}
class FlyVehicle{
    public void run(String FlyVehicle){
        System.out.println(FlyVehicle +"在天空中运行");
    }
}
class WhiterVehicle{
    public void run(String WhiterVehicle){
        System.out.println(WhiterVehicle + "在水中运行");
    }
}



-----------------------------------------------------------------------------
package Singleresponsibility;

public class SingleResponsibility3 {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        vehicle.runEarth("汽车");
        vehicle.runFly("飞机");
        vehicle.runWhiter("轮船");
    }
}
/*
* 方案三分析
* 1、这种修改方法没有对原来的类做大的修改，只是增加方法
* 2、这里虽然没有在类的这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责原则
* */
class Vehicle{
    public void runEarth(String EarthVehicle){
        System.out.println(EarthVehicle+"在公路上运行");
    }
    public void runFly(String FlyVehicle){
        System.out.println(FlyVehicle+"在天空上运行");
    }
    public void runWhiter(String WhiterVehicle){
        System.out.println(WhiterVehicle+"在海中运行");
    }
}
```

## 接口隔离原则(Interface Segregation Principle)

> 1)客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上
> 2)先看一张图	
>
> ![](C:\Users\强上女闺蜜\Pictures\Camera Roll\设计模式\屏幕截图 2021-12-17 003514.png)
>
> 3）类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现它们不需要的方法
>
> 4）按隔离原则应当这样处理：
>
> 将接口Interface拆分为独立的几个接口（案例里我们拆分为3个接口），类A和类C分别于它们需要的接口建立依赖关系，也就是采用接口隔离原则
>
> ![](C:\Users\强上女闺蜜\Pictures\Camera Roll\设计模式\屏幕截图 2021-12-17 003114.png)

> 传统方法的问题和使用接口隔离原则改进
>
> 1)类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现它们不需要的方法
>
> 2)将接口Interface拆分为独立的几个接口，类A和类C分别于它们需要的接口建立依赖关系，也就是采用接口隔离原则
>
> 3)接口Interface中出现的方法，根据实际情况拆分为三个接口
>
> 4）应用案例

```java
package Segregation;

public class Segregation1 {
    public static void main(String[] args) {
        A a = new A();
        a.depend1(new B());//A类通过接口去依赖(使用)B类
        C c = new C();
        c.depend1(new D());
    }
}

interface interface1 {
    void operation1();

    void operation2();

    void operation3();

    void operation4();

    void operation5();
}

class B implements interface1 {

    @Override
    public void operation1() {
        System.out.println("B实现了operation1方法");
    }

    @Override
    public void operation2() {
        System.out.println("B实现了operation2方法");
    }

    @Override
    public void operation3() {
        System.out.println("B实现了operation3方法");
    }

    @Override
    public void operation4() {
        System.out.println("B实现了operation4方法");
    }

    @Override
    public void operation5() {
        System.out.println("B实现了operation5方法");
    }
}

class D implements interface1 {

    @Override
    public void operation1() {
        System.out.println("D实现了operation1方法");
    }

    @Override
    public void operation2() {
        System.out.println("D实现了operation2方法");
    }

    @Override
    public void operation3() {
        System.out.println("D实现了operation3方法");

    }

    @Override
    public void operation4() {
        System.out.println("D实现了operation4方法");

    }

    @Override
    public void operation5() {
        System.out.println("D实现了operation5方法");

    }
}

class A {//A类通过接口依赖（使用）B类，但是只会用到1，2，3 方法

    public void depend1(interface1 i) {
        i.operation1();
    }

    public void depend2(interface1 i) {
        i.operation2();
    }

    public void depend3(interface1 i) {
        i.operation3();
    }

}

class C {//A类通过接口依赖（使用）B类，但是只会用到1，4，5 方法
    public void depend1(interface1 i) {
        i.operation1();
    }

    public void depend4(interface1 i) {
        i.operation4();
    }

    public void depend5(interface1 i) {
        i.operation5();
    }
}


-----------------------------------------------------------------------------
采用接口隔离原则后的代码
package Segregation.improve;

public class Segregation1 {
    public static void main(String[] args) {
        A a = new A();
        a.depend1(new B());//A类通过接口去依赖(使用)B类
        a.depend2(new B());
        a.depend3(new B());
        C c = new C();
        c.depend1(new D());
        c.depend4(new D());
        c.depend5(new D());
    }
}

interface interface1 {
    void operation1();
}

interface interface2 {
    void operation2();

    void operation3();
}

interface interface3 {
    void operation4();

    void operation5();
}

class B implements interface1, interface2 {

    @Override
    public void operation1() {
        System.out.println("B实现了operation1方法");
    }

    @Override
    public void operation2() {
        System.out.println("B实现了operation2方法");
    }

    @Override
    public void operation3() {
        System.out.println("B实现了operation3方法");
    }

}

class D implements interface1, interface3 {

    @Override
    public void operation1() {
        System.out.println("D实现了operation1方法");
    }

    @Override
    public void operation4() {
        System.out.println("D实现了operation4方法");
    }

    @Override
    public void operation5() {
        System.out.println("D实现了operation5方法");

    }
}

class A {
    public void depend1(interface1 i) {
        i.operation1();
    }

    public void depend2(interface2 i) {
        i.operation2();
    }

    public void depend3(interface2 i) {
        i.operation3();
    }
}

class C {
    public void depend1(interface1 i) {
        i.operation1();
    }

    public void depend4(interface3 i) {
        i.operation4();
    }

    public void depend5(interface3 i) {
        i.operation5();
    }
}
```

## 依赖倒转（倒置）原则

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 依赖倒置的中心思想就是面向接口编程
4. 依赖倒置原则就是基于这样的设计理念：相对与细节的多变性，抽象的东西要稳定得多，以抽象为基础搭建的架构比以前用细节为基础的架构要稳定的多，在Java中，抽象指的是接口或者抽象类，细节就是具体的实现类
5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成



```java
package dependencyinversion;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/16/18:45
 * @Description:
 */
public class DependencyInversion {
    public static void main(String[] args) {
        Person person = new Person();
        person.receive(new Email());

    }
}


class Email{
    public String getInfo(){
        return "email:Hello World";
    }
}
/**
* @Description: 完成Person接受信息的功能
 * 方式一分析：
 *  1、简单，比较容易想到
 *  2、如果我们获取的对象是微信，短信等等，则新增类，同时Person也要增加相应的接受方法
 *  3、解决思路：引入一个抽象的接口IReceiver，表示接收者，这样的person类与接口IReceiver发生依赖
 *      因为Email，微信等等属于接受的范围，他们各自实现IReceiver,接口就ok这样我们就符合依赖倒置原则
* @Param:
* @return:
* @Date: 2022/5/16
*/
class Person{
    public void receive(Email email){
        System.out.println(email.getInfo());
    }
}
```

```Java
package dependencyinversion;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/16/19:03
 * @Description:
 */
public class DependencyInversion1 {
    public static void main(String[] args) {
        Person1 person1 = new Person1();
        person1.receive(new Email1());
        person1.receive(new WeiXin());

    }
}

interface IReceive{
    String getInfo();
}

class Email1 implements IReceive{
    public String getInfo(){
        return "email:Hello World";
    }
}

class WeiXin implements IReceive{

    @Override
    public String getInfo() {
        return "微信信息：Hello World";
    }
}
/**
 * @Description: 完成Person接受信息的功能
 * 方式二：依赖倒置
 * @Param:
 * @return:
 * @Date: 2022/5/16
 */
class Person1{
    public void receive(IReceive iReceive){
        System.out.println(iReceive.getInfo());
    }
}

```

**依赖关系传递的三种方式**

1、接口传递

2、构造方法传递

3、setter方式传递

**依赖倒转原则的注意事项和细节**

1. 低层模块经量都要有抽象类或接口，或者两者都有，程序稳定性更好。
2. 变量的声明类型经量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
3. 继承时遵循里氏替换原则

## 里氏替换原则

OO**中的继承性的思考和说明**

1. 继承包含这样一层含义:父类中凡是已经实现好的方法，实际上是在规定规范和契约，虽然他不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
2. 继承在给程序设计带来便利的同时，也带来了弊端，比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障

**基本介绍**

1. 里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的
2. 如果对某个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2时类型类型T1的子类型，换句话说，所有引用基类的地方必须能透明地使用其子类的对象。
3. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
4. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适合的情况下，可以通过聚合，组合，依赖来解决问题。

```Java
package replacement;

/**
 * Created with IntelliJ IDEA.
 *  里氏替换原则
 * @Date: 2022/05/17/18:37
 * @Description:
 */
public class Replacement {
    public static void main(String[] args) {
        A a = new A();
        System.out.println("11+3="+a.sum(11,3));

        B b = new B();
        System.out.println("11+3="+b.sum1(11,3));
        System.out.println("11+3="+b.sum(11,3));

    }
}
class A{
    public Integer sum(int a,int b){
        return a+b;
    }
}

class B extends A{
    public Integer sum1(int a, int b){
        return a+b;
    }
    public Integer sum(int a,int b){
        return a-b;
    }
}
```



## 开闭原则

1. 开闭原则是编程中最基础，最重要的设计原则
2. 一个软件实体如类，模块和函数应该对扩展开发，对修改关闭，用抽象构建框架，用实现扩展细节
3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化   

## 迪米特法则

1. 一个对象应该对其他对象保持最少的了解
2. 类与类关系越密切，耦合度越大
3. 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供简单的public方法，不对外泄露任何信息
4. 迪米特法则还有个更简单的定义：只与直接的朋友通信
5. **直接的朋友：**每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系。我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部

## 合成复用原则

原则是尽量使用合成/聚合的方式，而不是使用继承 



# 设计者模式类型

**设计模式分成三种类型，共23种**

1. 创建者模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2. 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、 外观模式、享元模式、代理模式。
3. 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）



## 单例模式

**单例设计模式介绍**

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实列，并且该类只提供一个取得其对象实例的方法（静态方法）



比如Mybatis的SessionFactory，它充当数据存储源的代理，并负责创建session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单列模式。



**单例模式有八种方式：**

1. **饿汉式（静态常量）**
2. **饿汉式（静态代码块）**
3. 懒汉式（线程不安全）
4. 懒汉式（线程安全，同步方法）
5. 懒汉式（线程安全，同步代码块）
6. **双重检查**
7. **静态内部类**
8. **枚举**



### **饿汉式（静态常量）**

步骤如下：

1. 构造器私有化（防止new）
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法。getInstance
4. 代码实现

```Java
package singleton;

/**
 * Created with IntelliJ IDEA.
 * 饿汉式（静态常量）
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

/**
 * @Description: 饿汉式（静态常量）
 * @Param:
 * @return:
 * @Date: 2022/5/18
 */
class Singleton {

    //1、构造器私有化，外部不能new
    private Singleton() {

    }

    //2、本类内部创建对象实例
    private static final Singleton instance = new Singleton();

    //3、提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}

```



**优缺点说明**

1. 优点：这种写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步问题。
2. 缺点：在类装载的时候就完成实例化，没有达到lazy Loading的效果。如果从始至终从未使用这个实例，则会造成内存的浪费
3. 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果
4. 结论：这种单例模式可用，可能造成内存浪费

### **饿汉式（静态代码块）**

```Java 
package singleton.staticcodeblock;

/**
 * Created with IntelliJ IDEA.
 * 饿汉式（静态代码块）
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

/**
 * @Description: 饿汉式（静态代码块）
 * @Param:
 * @return:
 * @Date: 2022/5/18
 */
class Singleton {

    //1、构造器私有化，外部不能new
    private Singleton() {

    }

    //2、本类内部创建对象实例
    private static Singleton instance;

    //在静态代码块中，创建单例实例化对象
    static {
        instance = new Singleton();
    }

    //3、提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }
}

```

**优缺点说明：**

1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。
2. 结论：这种单例模式可用，可能造成内存浪费



### **懒汉式（线程不安全）**

```Java
package singleton.lazythreadsarenotsafe;

/**
 * Created with IntelliJ IDEA.
 * 懒汉式（线程不安全）
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

/**
 * @Description: 懒汉式（线程不安全）
 * @Param:
 * @return:
 * @Date: 2022/5/18
 */
class Singleton {

    //1、构造器私有化，外部不能new
    private Singleton() {

    }

    //2、本类内部创建对象实例
    private static Singleton instance;


    //3、提供一个公有的静态方法，当使用到该方法，才会去创建instance
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

```

**优缺点说明**

1. 起到lazy loading的效果，但是只能在单线程下使用
2. 如果在多线程下，一个线程进入if（instance==null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式
3. 结论：在实际开发中，不要使用这种方式。

### 懒汉式（线程安全，同步方法）

```Java
package singleton.lazythreadsafety;

/**
 * Created with IntelliJ IDEA.
 * 懒汉式（线程安全）
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

/**
 * @Description: 懒汉式（线程安全）
 * @Param:
 * @return:
 * @Date: 2022/5/18
 */
class Singleton {

    //1、构造器私有化，外部不能new
    private Singleton() {

    }

    //2、本类内部创建对象实例
    private static Singleton instance;


    //3、提供一个公有的静态方法，加入同步处理代码，使得线程安全
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

```

**优缺点说明：**

1. 解决了线程不安全问题
2. 效率太低了，每个线程在想获得类的实例化时候，执行getInstance（）方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例直接return就行了。方法进行同步效率太低。
3. 结论：在实际开发中，不推荐使用这种方式

### 懒汉式（线程安全，同步代码块）

```Java
package singleton.lazythreadsafety;

/**
 * Created with IntelliJ IDEA.
 * 懒汉式（线程安全，同步代码块）
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

/**
 * @Description: 懒汉式（线程安全,同步代码块）
 * @Param:
 * @return:
 * @Date: 2022/5/18
 */
class Singleton {

    //1、构造器私有化，外部不能new
    private Singleton() {

    }

    //2、本类内部创建对象实例
    private static Singleton instance;


    //3、提供一个公有的静态方法，加入同步处理代码，
    public static  Singleton getInstance() {
        if (instance == null) {
            synchronized （Singleton.class）{
                 instance = new Singleton();
            }
        }
        return instance;
    }
}
```

**优缺点说明**

1. 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的代码块
2. 但是这种同步并不能起到线程同步的作用，跟第三种实现方式遇到的情形一致，假如一个线程进入if（Singleton==null）判断语句，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例
3. 结论：在实际开发中，不能使用这种方式

### 双重检查

```Java
package singleton.doubleinspection;

/**
 * Created with IntelliJ IDEA.
 * 双重检查
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

/**
 * @Description: 双重检查
 * @Param:
 * @return:
 * @Date: 2022/5/18
 */
class Singleton {

    //1、构造器私有化，外部不能new
    private Singleton() {

    }

    //2、本类内部创建对象实例
    private static volatile Singleton instance;

    //3、提供一个公有的静态方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```

**优缺点说明**

1. Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if（instance==null）检查。这样就可以保证线程安全了
2. 这样，实例化代码只用执行一次，后面再次访问时，判断if（instance==null），直接return实例化对象，也避免了反复进行方法同步
3. 线程安全：延迟加载。效率较高
4. 结论：在实际开发中，推荐使用这种单例设计模式

### 静态内部类

```Java
package singleton.staticinternalclass;

/**
 * Created with IntelliJ IDEA.
 * 静态内部类
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
    }
}

/**
 * @Description: 静态内部类
 * @Param:
 * @return:
 * @Date: 2022/5/18
 */
class Singleton {

    //1、构造器私有化，外部不能new
    private Singleton() {

    }

    //2、本类内部创建对象实例
    private static volatile Singleton instance;

    //写一个静态内部类，该类中有一个静态属性Singleton
    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }


    //3、提供一个公有的静态方法,直接返回SingletonInstance.INSTANCE
    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

**优缺点说明**

1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
2. 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance（）方法，才会装载SingletonInstance类，从而完成Singleton的实例化
3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助完美保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
4. 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
5. 结论：推荐使用。

### 枚举

```Java
package singleton.enumtype;

/**
 * Created with IntelliJ IDEA.
 * 枚举
 *
 * @Date: 2022/05/18/18:55
 * @Description:
 */
public class SingletonType1 {
    public static void main(String[] args) {
        //测试
        Singleton instance1 = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System.out.println(instance1 == instance2);
        System.out.println(instance1.hashCode());
        System.out.println(instance2.hashCode());
        instance1.say();
        instance2.say();
    }
}
enum Singleton{

    INSTANCE; //属性

    public void say(){
        System.out.println("Hello World");
    }
}
```

**优缺点说明**

1. 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
2. 这种方式时Effective java作者Josh Bloch提倡的方式
3. 结论：推荐使用

### **单例模式注意事项和细节说明**

1. 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
3. 单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即：重复级对象），但又经常用到的对象（工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）

## 简单工厂模式

**看一个具体的需求**

看一个披萨的项目：要便于披萨种类的扩展，要便于维护

1. 披萨的种类很多（比如奶酪，希腊等）
2. 披萨的制作有prepare，bake，cut，box
3. 完成披萨订购任务

```Java
package simplefactorymodel.pizza;

/**
 * Created with IntelliJ IDEA.
 *  披萨类
 * @Date: 2022/05/23/8:46
 * @Description:
 */
public abstract class Pizza {
    protected String name;

    public abstract void prepare();

    public void bake(){
        System.out.println(name+"bakeing;");
    }
    public void cut(){
        System.out.println(name+"cuting;");
    }
    public void box(){
        System.out.println(name+"boxing;");
    }


    public void setName(String name) {
        this.name = name;
    }
}

```

```java
package simplefactorymodel.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/8:50
 * @Description:
 */
public class CheesePizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println("制作奶酪披萨，准备原材料");
    }
}

```

```java
package simplefactorymodel.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/8:50
 * @Description:
 */
public class GreekPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println("制作希腊披萨，准备原材料");
    }
}

```

```java
package simplefactorymodel.orderpizza;

import simplefactorymodel.pizza.CheesePizza;
import simplefactorymodel.pizza.GreekPizza;
import simplefactorymodel.pizza.Pizza;

import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/8:54
 * @Description:
 */
public class OrderPizza {

    private Pizza pizza;

    public OrderPizza() {
        String type;
        do {
            type = getType();
            if (type.equals("奶酪")){
                pizza = new CheesePizza();
                pizza.setName("奶酪披萨");
            }else if (type.equals("希腊")){
                pizza = new GreekPizza();
                pizza.setName("希腊披萨");
            }else{
                break;
            }
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while (true);

    }
    public String  getType(){
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入订购的种类");
        String order = scanner.next();
        return order;
    }
}
```

```java
package simplefactorymodel.orderpizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/9:04
 * @Description:
 */
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza();
    }
}
```

**传统方式的优缺点**

1. 优点时比较好理解，简单易操作
2. 缺点是违反了设计模式的ocp原则，即对外扩展开放，对修改关闭，及当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码



**改进分析**

**分析**：修改代码可以接受，但是如果我们在其他的地方也有创建pizza的代码，就意味着，也需要修改，而创建pizza的代码，往往有多处。

**思路：**把创建Pizza对象封装到一个类中，这样我们有新的pizza种类时，只需要修改该类即可，其他有创建到pizza对象的代码就不要修改了-->简单工厂模式



**简单工厂模式基本介绍**

1. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
2. 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）
3. 在软甲开发中，当我们会用到大量的创建某种、某类或某对象时，就会使用到工厂模式



**使用工厂模式优化披萨项目**

```java
package simplefactorymodel.orderpizza;

import simplefactorymodel.pizza.CheesePizza;
import simplefactorymodel.pizza.GreekPizza;
import simplefactorymodel.pizza.Pizza;
import simplefactorymodel.simplefactory.SimpleFactory;

import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/8:54
 * @Description:
 */
public class OrderPizza {

    private Pizza pizza;

    SimpleFactory simpleFactory;

    public OrderPizza(SimpleFactory simpleFactory) {
     /*   String type;
        do {
            type = getType();
            if (type.equals("奶酪")){
                pizza = new CheesePizza();
                pizza.setName("奶酪披萨");
            }else if (type.equals("希腊")){
                pizza = new GreekPizza();
                pizza.setName("希腊披萨");
            }else{
                break;
            }
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while (true);*/
        setSimpleFactory(simpleFactory);
    }


    public void setSimpleFactory(SimpleFactory simpleFactory) {

        String type = "";

        this.simpleFactory = simpleFactory;

        do {
            type = getType();
            pizza = this.simpleFactory.createPizza(type);
            if (pizza != null) {
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            } else {
                System.out.println("未找到该种类");
                break;
            }

        } while (true);
    }

    public String getType() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入订购的种类");
        String order = scanner.next();
        return order;
    }
}
```

```java
package simplefactorymodel.simplefactory;

import simplefactorymodel.pizza.CheesePizza;
import simplefactorymodel.pizza.GreekPizza;
import simplefactorymodel.pizza.Pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/9:45
 * @Description:
 */
public class SimpleFactory {

    public Pizza createPizza(String type) {
        System.out.println("简单工厂模式");
        Pizza pizza = null;
        if (type.equals("奶酪")) {
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        } else if (type.equals("希腊")) {
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        }
        return pizza;
    }
}
```

## **工厂方法模式**

**工厂方法模式介绍**

工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现

工厂方法模式：定义一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类

```Java
package factorymethod.pizza;

/**
 * Created with IntelliJ IDEA.
 *  披萨类
 * @Date: 2022/05/23/8:46
 * @Description:
 */
public abstract class Pizza {
    protected String name;

    public abstract void prepare();

    public void bake(){
        System.out.println(name+"bakeing;");
    }
    public void cut(){
        System.out.println(name+"cuting;");
    }
    public void box(){
        System.out.println(name+"boxing;");
    }


    public void setName(String name) {
        this.name = name;
    }
}
```

```Java
package factorymethod.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:46
 * @Description:
 */
public class BJCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京奶酪披萨");
        System.out.println("北京奶酪披萨 准备原材料");
    }
}
```

```java
package factorymethod.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:48
 * @Description:
 */
public class BJGreekPizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京希腊披萨");
        System.out.println("北京希腊披萨 准备原材料");
    }
}
```

```java
package factorymethod.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:49
 * @Description:
 */
public class LDCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("伦敦奶酪披萨");
        System.out.println("伦敦奶酪披萨 准备原材料");
    }
}
```

```java
package factorymethod.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:50
 * @Description:
 */
public class LDGreekPizza extends Pizza {

    @Override
    public void prepare() {
        setName("伦敦希腊披萨");
        System.out.println("伦敦希腊披萨 准备原材料");
    }
}

```

```java
package factorymethod.order;

import factorymethod.pizza.Pizza;

import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:51
 * @Description:
 */
public abstract class Order {

    abstract Pizza createPizza(String type);
    Pizza pizza;

    boolean flag = true;

    public Order() {
        do {
            String type = getType();
            createPizza(type);
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while (flag);
    }

    public String getType() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入订购的种类");
        String order = scanner.next();
        return order;
    }
}
```

```java
package factorymethod.order;

import factorymethod.pizza.BJCheesePizza;
import factorymethod.pizza.BJGreekPizza;
import factorymethod.pizza.Pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:56
 * @Description:
 */
public class BJOrder extends Order{
    @Override
    Pizza createPizza(String type) {
        out:if (type.equals("奶酪")){
            pizza = new BJCheesePizza();
        }else if (type.equals("希腊")){
            pizza = new BJGreekPizza();
        }else{
            break out;
        }
        return pizza;
    }
}
```

```java
package factorymethod.order;

import factorymethod.pizza.*;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:58
 * @Description:
 */
public class LDOrder extends Order{
    @Override
    Pizza createPizza(String type) {
        if (type.equals("奶酪")){
            pizza = new LDCheesePizza();
        }else if (type.equals("希腊")){
            pizza = new LDGreekPizza();
        }else {
            flag=false;
        }

        return pizza;
    }
}
```

```java
package factorymethod.order;

import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:59
 * @Description:
 */
public class PizzaStore {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入想吃的口味地区");
        String s = scanner.next();
        if (s.equals("北京")){
            new BJOrder();
        }else if (s.equals("伦敦")){
            new LDOrder();
        }else {
            System.out.println("该地区还未有");
        }
    }
}
```

## 抽象工厂模式

**基本介绍**

1. 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象派，而无需指明具体的类
2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合
3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。
4. 将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类，程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展

```java
package absfactory.pizza;

/**
 * Created with IntelliJ IDEA.
 *  披萨类
 * @Date: 2022/05/23/8:46
 * @Description:
 */
public abstract class Pizza {
    protected String name;

    public abstract void prepare();

    public void bake(){
        System.out.println(name+"bakeing;");
    }
    public void cut(){
        System.out.println(name+"cuting;");
    }
    public void box(){
        System.out.println(name+"boxing;");
    }


    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package absfactory.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:46
 * @Description:
 */
public class BJCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("北京奶酪披萨");
        System.out.println("北京奶酪披萨 准备原材料");
    }
}
```

```java
package absfactory.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:48
 * @Description:
 */
public class BJGreekPizza extends Pizza {
    @Override
    public void prepare() {
        setName("北京希腊披萨");
        System.out.println("北京希腊披萨 准备原材料");
    }
}
```

```java
package absfactory.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:49
 * @Description:
 */
public class LDCheesePizza extends Pizza {
    @Override
    public void prepare() {
        setName("伦敦奶酪披萨");
        System.out.println("伦敦奶酪披萨 准备原材料");
    }
}
```

```java
package absfactory.pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:50
 * @Description:
 */
public class LDGreekPizza extends Pizza {

    @Override
    public void prepare() {
        setName("伦敦希腊披萨");
        System.out.println("伦敦希腊披萨 准备原材料");
    }
}
```

```java
package absfactory.order;

import absfactory.pizza.Pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/18:38
 * @Description:
 */
public interface AbsFactory {

    abstract Pizza createPizza(String type);
}
```

```java
package absfactory.order;

import absfactory.pizza.BJCheesePizza;
import absfactory.pizza.BJGreekPizza;
import absfactory.pizza.Pizza;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/18:40
 * @Description:
 */
public class BJOrder implements AbsFactory {

    Pizza pizza;

    @Override
    public Pizza createPizza(String type) {
        if (type.equals("奶酪")) {
            pizza = new BJCheesePizza();
        } else if (type.equals("希腊")) {
            pizza = new BJGreekPizza();
        }else {
            return null;
        }
        return pizza;
    }
}
```

```java
package absfactory.order;

import absfactory.pizza.LDCheesePizza;
import absfactory.pizza.LDGreekPizza;
import absfactory.pizza.Pizza;
import factorymethod.order.Order;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/14:58
 * @Description:
 */
public class LDOrder implements AbsFactory {

    Pizza pizza;

    @Override
    public Pizza createPizza(String type) {
        if (type.equals("奶酪")) {
            pizza = new LDCheesePizza();
        } else if (type.equals("希腊")) {
            pizza = new LDGreekPizza();
        }
        return pizza;
    }
}
```

```java
package absfactory.order;

import absfactory.pizza.Pizza;

import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/18:45
 * @Description:
 */
public class Order {
    AbsFactory absFactory;
    Pizza pizza;

    public Order(AbsFactory absFactory) {
        setAbsFactory(absFactory);
    }
    private void setAbsFactory(AbsFactory absFactory){
        this.absFactory = absFactory;
        while (true){
            String type = getType();
            pizza = absFactory.createPizza(type);
            if (pizza!=null){
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            }else {
                System.out.println("还没有该口味");
                break;
            }
        }
    }
    public String getType() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入订购的种类");
        String order = scanner.next();
        return order;
    }
}
```

```java
package absfactory.order;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/18:48
 * @Description:
 */
public class OrderStore {
    public static void main(String[] args) {
        new Order(new BJOrder());
    }
}
```

## 工厂模式小结

1. 工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦，从而提高项目的扩展和维护性
2. 三种工厂模式
3. 设计模式的依赖抽象原则

- 建立对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回，有的书上说，变量不要直接持有具体类的引用
- 不要让类继承具体类，而是继承抽象类或者是实现interface接口
- 不要覆盖类中已经实现的方法

## 原型模式

克隆羊项目

克隆10只羊

```java
package prototypemode.sheep;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/19:44
 * @Description:
 */
public class Sheep {
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }
}
```

```java
package prototypemode.sheep;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/19:45
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        for (int i = 0 ; i<10 ;i++){
            Sheep sheep = new Sheep("tom", 1, "白色");
            System.out.println(sheep);
        }
    }
}
```

**传统方式的优缺点**

1. 优点是比较好理解，简单易操作
2. 在创建新对象时，总是需要重新获取原始对象属性，如果创建的对象比较复杂时，效率较低
3. 总是需要重新初始化对象，而不是动态的获得对象运行时的状态，不够灵活
4. 改进的思路分析
5. Java中object类是所有类的根类，object类提供了一个clone（）方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须实现一个接口Cloneable该接口表示该类能够复制且具有复制的能力=》原型模式

```java
package prototypemode.improve;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/23/19:44
 * @Description:
 */
public class Sheep implements Cloneable {
    private String name;
    private int age;
    private String color;
    private String address = "新疆";

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                ", address='" + address + '\'' +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```Java
package prototypemode.improve;


/**
 * Created with IntelliJ IDEA.
 * 浅拷贝
 *内存地址是一样的
 * @Date: 2022/05/23/19:45
 * @Description:
 */
public class Client {
    public static void main(String[] args) {
        Sheep sheep = new Sheep("tom", 1, "白色");
        Integer num = 10;
        for (int i = 0; i < num; i++) {
            try {
                Sheep sheep1 = (Sheep) sheep.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            System.out.println(sheep);
        }
    }
}
```

**原型模式基本介绍**

1. 原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
2. 原型模式是一种创建型设计模式，允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节
3. 工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们给自己来实施创建，即对象，clone（）

### 浅拷贝的介绍

1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。
3. 前面我们克隆羊就是浅拷贝
4. 浅拷贝是使用默认的clone（）方法来实现
5. sheep = （Sheep）super.clone();

### **深拷贝基本介绍**

1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝
3. 深拷贝实现方式1：重写clone方法来实现深拷贝
4. 深拷贝实现方式2：通过对象序列化实现深拷贝

```Java
package prototypemode.deepclone;

import java.io.Serializable;

/**
 * Created with IntelliJ IDEA.
 *
 * @Date: 2022/05/24/17:20
 * @Description:
 */
public class DeepCloneableTarget implements Serializable,Cloneable {

    private static final long serialVersionUID = 1L;

    private String cloneName;

    private String cloneClass;

    public DeepCloneableTarget(String cloneName, String cloneClass) {
        this.cloneName = cloneName;
        this.cloneClass = cloneClass;
    }

    public String getCloneName() {
        return cloneName;
    }

    public void setCloneName(String cloneName) {
        this.cloneName = cloneName;
    }

    public String getCloneClass() {
        return cloneClass;
    }

    public void setCloneClass(String cloneClass) {
        this.cloneClass = cloneClass;
    }

    @Override
    public String toString() {
        return "DeepCloneableTarget{" +
                "cloneName='" + cloneName + '\'' +
                ", cloneClass='" + cloneClass + '\'' +
                '}';
    }

    /**
    * @Description: 因为是引用数据类型，因此我们使用默认的clone就行了
    * @Param:
    * @return:
    * @Date: 2022/5/24
    */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```Java
package prototypemode.deepclone;

import java.io.*;

/**
 * Created with IntelliJ IDEA.
 *
 * @author 67636
 * @Date: 2022/05/24/17:23
 * @Description:
 */
public class DeepProtoType implements Serializable, Cloneable {


    private String name;
    private DeepCloneableTarget deepCloneableTarget;

    public DeepProtoType(String name, DeepCloneableTarget deepCloneableTarget) {
        this.name = name;
        this.deepCloneableTarget = deepCloneableTarget;
    }

    @Override
    public String toString() {
        return "DeepProtoType{" +
                "name='" + name + '\'' +
                ", deepCloneableTarget=" + deepCloneableTarget +
                '}';
    }

    /**
     * @Description: 深拷贝 方式一使用clone方法
     * @Param: []
     * @return: []
     * @Date: 2022/5/24
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {

        //这里是完成基本类型的克隆
        Object deep = null;
        deep = super.clone();


        //对引用类型的属性进行单独处理
        DeepProtoType deepProtoType = (DeepProtoType) deep;
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();

        return deepProtoType;
    }
    
    /**
    * @Description: 深拷贝 - 方式二 通过对象的序列化实现（推荐）
    * @Param: []
    * @return: []
    * @Date: 2022/5/24
    */
    public Object deepClone() throws Exception {

        //创建流对象
        ByteArrayOutputStream byteArrayOutputStream = null;
        ObjectOutputStream objectOutputStream = null;
        ByteArrayInputStream byteArrayInputStream = null;
        ObjectInputStream objectInputStream = null;


        try {
            //序列化
            byteArrayOutputStream = new ByteArrayOutputStream();
            objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            //当前这个对象以对象流的方式输出
            objectOutputStream.writeObject(this);

            //反序列化
            byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
            objectInputStream = new ObjectInputStream(byteArrayInputStream);
            DeepProtoType readObject = (DeepProtoType) objectInputStream.readObject();

            return readObject;

        } catch (IOException e) {
            e.printStackTrace();
            return null;
        } finally {
            //关闭流
            byteArrayOutputStream.close();
            objectOutputStream.close();
            byteArrayInputStream.close();
            objectInputStream.close();

        }

    }
}
```

```java
package prototypemode.deepclone;

/**
 * Created with IntelliJ IDEA.
 *
 * @author 67636
 * @Date: 2022/05/24/17:29
 * @Description:
 */
public class Client {
    public static void main(String[] args) throws Exception {
        DeepProtoType protoType = new DeepProtoType("武松", new DeepCloneableTarget("打虎", "英雄"));
    /*    //方式一
        DeepProtoType clone = (DeepProtoType)protoType.clone();*/


        //方式二
        DeepProtoType clone = (DeepProtoType) protoType.deepClone();
        System.out.println(protoType);
        System.out.println(protoType.hashCode());
        System.out.println(clone.hashCode());
        System.out.println(protoType==clone);
    }
}
```

### **原型模式的注意事项和细节**

1. 创建新对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2. 不用重新初始化对象，而是动态地或的对象运行时的状态
3. 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码
4. 在实现深克隆的时候可能需要比较复制的代码
5. **缺点:**需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp严重，这点需要注意

## 建造者模式

 
